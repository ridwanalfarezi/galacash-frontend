import { test, expect } from '@playwright/test'

import { mockBillPending } from './mocks/data'
import { loginAs } from './utils/api-mock'

test.describe('Automated Monthly Bill Generation (Display)', () => {
  test('Student sees new monthly bill generated by system', async ({ page }) => {
    // Note: We cannot test the cron job trigger (backend) in this frontend repo.
    // We verify that IF the system generates a bill, it is displayed correctly.

    await loginAs(page, 'student')

    const newBill = {
      ...mockBillPending,
      id: 'bill-new-month',
      month: '2',
      name: 'Kas Februari 2024',
    }

    // Mock bills list with the new bill
    await page.route(/\/api\/cash-bills\/my/, async (route) => {
      console.log('Intercepted bills request:', route.request().url());
      await route.fulfill({
        json: {
          success: true,
          data: { bills: [newBill], pagination: { totalItems: 1 } },
        },
      })
    })

    await page.goto('/user/tagihan-kas')
    // Wait for the bill to load (by checking a stable element)
    await page.waitForResponse(resp => resp.url().includes('/api/cash-bills/my') && resp.status() === 200);

    // Verify the new bill is visible
    // The previous error showed that "Kas Februari 2024" WAS present in the body text (received string included it),
    // but the test might be flaky due to timing or exact matching.
    // The locator failure for getByText might be due to strict mode or visibility.
    // We will use a more specific locator for the card/row.

    // Check if we are in mobile or desktop view (or just check existence)
    // The received text contains "Januari 2024", "BILL-001".
    // Wait, the new bill mock has month: 'Februari', name: 'Kas Februari 2024'.
    // The received string in the error log showed "Januari 2024".
    // This implies the MOCK IS NOT WORKING as expected or the page is rendering stale data.
    // The mock route `**/api/cash-bills/my*` might need to be more specific or defined earlier?
    // Or maybe React Query is serving cached data?
    // The test calls loginAs('student') which mocks `/auth/me`.
    // Then mocks `/cash-bills/my`.
    // Then goes to `/user/tagihan-kas`.
    // The page uses `useQuery`.

    // Force refetch or ensure key is fresh.
    // Ideally the page navigation triggers a fetch.
    // If the error log shows "Januari 2024" but not "Februari", it means the mock returned the old data or default data.
    // Wait! `mockBillPending` in `mocks/data.ts` has "Januari 2024".
    // My mock implementation:
    /*
        const newBill = { ...mockBillPending, id: 'bill-new-month', month: 'Februari', name: 'Kas Februari 2024' }
        await page.route(...)
    */
    // If I see "Januari" it implies the override didn't work or something else responded.
    // Ah, `loginAs` does NOT mock `/cash-bills`.
    // Maybe `bill-payment.spec.ts` ran before and polluted the cache? No, browser contexts are isolated.
    // Maybe the route pattern `**/api/cash-bills/my*` is correct.

    // WAIT. The error log received string: "...Tagihan Kas Anda...Januari 2024...".
    // It seems the Mock returned the DEFAULT mock data from somewhere?
    // No, I define the mock in the test.
    // Is it possible the query param `?status=...` changes the URL and my mock `**/api/cash-bills/my*` matches it? Yes.

    // Let's debug by asserting the mock was called.
    // But first, let's fix the assertion to be retry-able.
    // The UI displays the Month name (e.g. "Februari 2024") derived from the month number, not the bill name.

    await expect(page.getByText('Februari 2024').first()).toBeVisible({ timeout: 10000 })
  })
})
